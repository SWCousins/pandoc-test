**Lesson Plan:** 
================

**Methods, Scoping and Debugging**
==================================

**Lesson Plan: Pseudocode**
===========================

(!!!)Open the
[[slidedeck]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/1-dot-1-2-slide-deck-part-2-debugging?module_item_id=33533)
for this lesson.

### **Purpose**

-   Pseudocode is a valuable development tool, it allows us to work
    > through the logic our program will need quickly and easily without
    > getting caught up in the details of proper syntax and import
    > statements.

-   Different types of pseudocode are used for different circumstances.
    > UML and flow charts can be used to design and explore interacts,
    > while using pseudocode similar to the language used in the program
    > can help explore the logic and data structures needed for the
    > finished program.

We realize that the simple programs learners are currently writing might
not need pseudocode to help architect their programs. But we\'ve found
that learners who start using pseudocode early tend to be more
comfortable planning programs as they move forward to developing more
and more complicated programs.

### **Narrative**

\"Now that you know some of the basics of how to write a program in C\#,
we'll be looking at a way to abstract the process of designing a
program. We'll be using pseudocode to plan our programs, but it is also
very useful for discovering and working through problems with
pre-existing code. Pseudocode is just a plain English description of a
program and the logical steps that it needs to be functional. This
description may look similar to the finished program but does not need
the Namespaces or import statements that a working program would need.
We'll also be using flowcharts to map and plan the interactions the
program will need to function.\"

Reinforce this point: **The IDE and all of its features are your tools
of the trade. These are the tools you use to make your money, do your
job, and advance in your career. Your time investment in learning the
tools of your trade will pay off many times over! One of the most
important of these tools is the debugger. Learn to use it well and it
will save you countless hours over your career.**

### **Learning Outcomes**

By the end of this lesson, the learners will be able to:

1.  Install Pseudocode for Visual Studio.

2.  Write a program in pseudocode.

3.  Compare and contrast pseudocode and C\# syntax.

4.  Explain a basic UML class diagram.

5.  Create a basic flowchart.

**Pseudocode Setup (5 min)**
----------------------------

*LO.1:* Install Pseudocode for Visual Studio

*LO.2:* Write a program in pseudocode

*LO.3:* Compare and contrast pseudocode and C\# syntax

Explain to the learners the concepts of using pseudocode.

-   Pseudocode allows us to draft a program quickly and easily.

-   This allows us to plan and analyze the logic behind our program.

**We Do: Pseudocode (10 min)**
------------------------------

// (!!!)There is a corresponding page in Student Materials [[We Do:
Debugging]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/we-do-debugging)

[[U01-M01-L2-DebuggingPractice-Activity.zip]{.ul}](https://bootcampspot.instructure.com/courses/255/files/82682/download?wrap=1)

We will set up a breakpoint. Have the learners work along with you as
you demonstrate.

1.  Have everyone open up the supplied version of Rectangular Paving
    > Company.

2.  Demonstrate setting a breakpoint on the first executable statement
    > (click in the gutter margin).

3.  Demonstrate starting the program in debug mode.

4.  Point out what the IDE looks like when the breakpoint is hit.

**Observing State and Stepping Through the Program (10 min)**
-------------------------------------------------------------

*LO.4: Step through program statements after hitting a breakpoint*

*LO.5: Continue program execution after hitting a breakpoint*

*LO.6: Observe program values while debugging*

Show the learners how to step through the code as part of the debugging
process.

1.  Point out the variables window.

2.  Show the learners what you see at this first breakpoint.

3.  Point out that we can only see the results of code that has
    > executed.

4.  Step through the code, pointing out how the debugger interacts with
    > a program that is asking for input from the user. Show them how to
    > switch between the variable window and the output window so they
    > see how to interact with the program even in debug mode.

5.  Point out how more variables become visible in the variable window
    > as you execute more statements.

6.  Show them how to click "Continue Execution" so the program runs to
    > completion.

**Recap (10 min)**
------------------

Recap what we learned in this lesson:

-   Pseudocode is a useful tool that every programmer should use.

-   Pseudocode allows us to abstract a program's logic for clear
    > analysis and quick planning.

-   We can step through a program's one function at a time.

-   This allows us to see what logic the program needs to function as
    > expected.

**Lesson Plan: Methods**
========================

Open the
[[slidedeck]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/1-dot-1-4-slide-deck-methods-and-scoping?module_item_id=33545)
for this lesson.

### **Purpose**

This session is all about methods. We want to frame this as adding
another organizational tool to the learner\'s toolbelt. Methods are a
way to package up blocks of code for reuse.Let them know that methods
are one of many tools that will allow them to follow the DRY (Don't
Repeat Yourself) principle.

### **Narrative**

Methods are a topic that a significant number of people struggle with at
first. Most people understand the concept over time, but it can take a
while to get there. We have found a few metaphors/analogies that can
help people understand methods more quickly. Tell learners that they
should use any of these that work for them and they should throw away
those that don\'t.

-   Methods are like mathematical functions. They take 0 or more inputs,
    > perform some work on the inputs, and then produce some kind of
    > result.

-   You can also think of methods as general solutions to a group of
    > related, specific problems. For example, we can have an expression
    > like 1 + 1 = 2. We can have another expression that is 1 + 2 = 3.
    > These are specific examples of adding two numbers together. A
    > method can provide a general solution to this problem as in a + b
    > = x.

-   You can think of methods like the order counter at the ice cream
    > shop. The inputs are your order and your money; the output is some
    > delicious ice cream. The ice cream you get depends on what you
    > ordered and whether or not you have enough money.

### **Learning Outcomes**

By the end of this lesson, the learners will be able to:

1.  Explain the purpose of methods.

2.  Define \"method signature.\"

3.  Explain method parameters and use them in a C\# program.

4.  Explain method return types and demonstrate them in a C\# program.

5.  Compare and contrast the four different method forms.

6.  Explain scoping.

7.  Define the DRY principle.

8.  Use static methods in a C\# program.

**The DRY Principle**
---------------------

*LO.7: Define the DRY principle*

\"In software engineering, Don\'t Repeat Yourself (DRY) is a principle
of software development aimed at reducing repetition of software
patterns, replacing it with abstractions or using data normalization to
avoid redundancy.

The DRY principle is stated as \'Every piece of knowledge must have a
single, unambiguous, authoritative representation within a system.\' The
principle was formulated by Andy Hunt and Dave Thomas in their book *The
Pragmatic Programmer*. They apply it quite broadly to include \'database
schemas, test plans, the build system, and even documentation.\'

When the DRY principle is applied successfully, a modification of any
single element of a system does not require a change in other logically
unrelated elements. Additionally, elements that are logically related
all change predictably and uniformly, and are thus kept in sync. Besides
using methods and subroutines in their code, Thomas and Hunt rely on
code generators, automatic build systems, and scripting languages to
observe the DRY principle across layers.\"

[Wikipedia: DRY Principle]{.ul}

[(Links to an external site.)]{.ul}

**Methods**
-----------

// (!!!)There is a corresponding page in Student Materials
[[Methods]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/methods)

### **The Purpose of Methods (5 min)**

*LO.1: Explain the purpose of methods*

Explain the purpose of methods:

-   Methods allow us to reuse code that we've already written.

-   Methods allow us to break down large, complex tasks into simpler
    > steps.

-   Methods don't really allow us to do anything we couldn't do
    > before---they just allow us to make our code better organized.

-   Methods are an organizational tool. Remember that a large part of
    > writing good software is good code organization.

**Defining Methods**
--------------------

### **Method Declaration (10 min)**

// (!!!)There is a corresponding page in Student Materials
[[Methods]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/methods)

-   We define a method by using a method declaration.

-   This is similar to declaring a variable: we have to declare the
    > method before we can use it.

-   The method declaration has several parts. We'll start with the
    > basics and build outward. The main pieces are:

    -   The name of the method

    -   The body (code block) of the method

    -   Any parameters that the method takes (more on this later)

    -   The type of data returned by this method (again, more on this
        > later)

    -   Parameters and return type

        -   Explanation for now: Oftentimes, methods take parameters and
            > return a value. Think of a simple method that adds two
            > numbers together: it would take two numbers in, as
            > parameters, and return the sum.

### **Full Method Description**

Discuss the full method description found in the slide:

\<access modifier\> \<return type\> \<method name\> (\<parameter list\>)
\<exception list\> {

\<method body\>

}

### **Method Example**

public static int greaterValue(int x, int y) {

if (x \> y) {

return x;

} else {

return y;

}

}

### **Method Signature (5 min)**

// (!!!)There is a corresponding page in Student Materials
[[Methods]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/methods)

*LO.2: Define \"method signature\"*

This is a definition that they will have to memorize:

-   The method signature is what we use to uniquely identify methods. It
    > consists of:

    -   Method name

    -   Parameter list

It does not include any other parts of the definition/declaration.

### **Example of a Method Signature**

Share this example of a method signature:

greaterValue(int x, int y)

### **Method Input Parameters (10 min)**

// (!!!)There is a corresponding page in Student Materials [[Method
Input
Parameters]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/method-input-parameters)

*LO.3: Explain method parameters and use them in a C\# program*

For now, we are concentrating on just the method signature (the method
name and parameter list).

The method name is pretty self-explanatory: we need a label for our
reusable block of code. We revisit naming conventions in a bit.

Parameters need a little more explanation:

-   Input parameters are placeholders for values that will be passed in
    > as data for the method to work on.

-   Methods can have zero or more parameters.

-   Methods with no parameters are useful for simply reusing code
    > blocks, but methods get really powerful when we pass parameters
    > in.

-   Example:

    -   Follow the example in the slidedeck of mult1and1, mult1and2.

    -   It is obviously better to parameterize a method that will
        > multiply any two numbers passed in.

    -   Compare this to mathematical equations: 1 \* 1 = 1, 1 \* 2 = 2,
        > etc. These are specific examples of the more general a \* b
        > = y.

    -   Methods are like general equations. The parameters are a and b;
        > the return value is y.

### **Example of Input Parameters**

Share this example of input parameters (multiply):

public static int mult1and1() {

int y = 1 \* 1;

return y;

}

public static int mult1and2() {

int y = 1 \* 2;

return y;

}

public static int mult(int a, int b) {

int y = a \* b;

return y;

}

### **Return Types (10 min)**

*LO.4: Explain method return types and demonstrate them in a C\#
program*

\"The example above multiplied a and b and returned the result. In that
case, the method returned an int. This is an example of a method return
type. We will look at the details of return types here.\"

-   Methods can return values to the caller, but they don't have to.

-   We have seen examples of both in our code so far:

    -   Console.WriteLine(...) does not return a value to the caller; it
        > simply does some work for us. It prints a value to the
        > console.

    -   The method Concole.ReadLine() does return a value to us.
        > Remember that it returns the string of characters the user
        > typed in.

-   Even if our method does not have a return value, we must always
    > indicate a return type. The return type for a method that returns
    > no value is void. Otherwise, it is the type of whatever value is
    > returned from the method.

### **Access Modifiers (5 min)**

We need to touch on access modifiers because we have the public modifier
all over the place. For now, we'll just be using public. Let them know
that we'll learn how to use this tool in future units.

**NOTE**: We don't want to go deep here because we haven't covered
classes and objects yet. This is another one of those topics that
learners will have to trust us on until later in the course when all the
pieces come together.

### **Method Naming Conventions (5 min)**

// There is a corresponding page in Student Materials
[[Methods]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/methods)

This is a review of the general naming conventions that we covered
earlier. It should make more sense now that we have a context for
methods.

Review the rules for naming a method:

-   Begins with a lowercase letter

-   Is a verb (if a single-word name)

-   Begins with a verb (if a multi-word name) followed by other words

-   Should be in camelCase (i.e., the first letter of the second and
    > following words should be capitalized)

### **Method Naming Conventions Examples**

-   calculateTotal

-   processOrders

-   storeUserData

-   checkCardValidity

### **Method Declaration Template / Rules (10 min)**

public static void doSomething(a,b,c) {

// Code that does something

}

We want to go back and put all of the information they just saw into
context. Go through the slide for declaration rules and go through each
part:

-   Access modifier: for now, we'll use public. Other values are
    > possible; we'll cover these later.

-   Return type: this indicates the data type of the value returned by
    > the method; use void if the method does not return a value.

-   Method name: the rules for identifiers apply here, but there are
    > additional conventions.

-   Parameter list: comma-delimited list of input parameters. Each
    > parameter consists of its data type followed by its identifier.
    > The parameter list must be enclosed in parentheses; if the method
    > has no parameters, you must use the empty parentheses.

-   Exception list: we'll cover this later.

-   Method body: the code block for this method.

### **Static Keyword:**

Many of the learners will have noticed that we're using static on all of
our methods. We're not going to get into the explanation of static
yet---we'll save that for the object-oriented part of the course. For
now, they just need to know that the static keyword is necessary for all
methods for the moment.

**BREAK (10 min)**
------------------

**Method Forms**
----------------

// There is a corresponding page in Student Materials [[Method
Forms]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/method-forms)

*LO.5: Compare and contrast the four different method forms*

Methods can take four forms. This section is meant to be a
review/reinforcement of the material presented above and to provide more
context to the learners.

### **Four Method Forms (5 min)**

Quickly list the four different forms (listed in the slides):

-   No return value, no parameters

-   Return value, no parameters

-   No return value, one or more parameters

-   Return value, one or more parameters

Emphasize that these are patterns that the learners will see over and
over. They need to memorize these and practice recognizing them. This
will become second nature very quickly.

### **No return value, no parameters (5 min)**

Go through the example in the slidedeck. Point out all the parts of the
declaration, the signature, and the fact that there is nothing returned:

public static void calcArea() {

int height = 10;

int width = 15;

int area = height \* width;

Console.WriteLine(area);

}

### **Return value, no parameters (5 min)**

Same thing here: point out that we have a return value in this example:

public static int calcArea() {

int height = 10;

int width = 15;

int area = height \* width;

return area;

}

### **No return value, one or more parameters (5 min)**

Point out that we now have parameters. Emphasize how they are declared:
just like declaring a variable, you need a data type and a name. There
is no return value for this example:

public static void calcArea(int height, int width) {

int area = height \* width;

Console.WriteLine(area);

}

### **Return value, one or more parameters (5 min)**

This is similar to the last one, but it has a return value:

public static int calcArea(int height, int width) {

int area = height \* width;

return area;

}

**Scope (5 min)**
-----------------

// There is a corresponding page in Student Materials
[[Scope]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/scope)

*LO.6: Explain scoping*

### **C\# Scopes**

The scope of a variable basically means where it is accessible from
within the rest of the code. We have the following scopes to deal with
in C\#:

-   Member variables / Class-level scope

    -   These variables are declared inside of a class (yet outside of
        > any method) and can be accessed anywhere inside the class.

    -   The following modifiers can be added to the variable to further
        > refine their scope:

        -   public

        -   protected

        -   default

        -   private

-   Local variables / Method-level scope

    -   Declared inside a method and not usable outside of it.

-   Loop variables / Block scope

    -   Declared inside a block and not usable outside of it.

**NOTE**: Be prepared to answer why this matters without going too much
into the weeds on it.

**Instructor Do: Using Methods (15 min)**
-----------------------------------------

// There is a corresponding page in Student Materials [[Instructor Do:
Using
Methods]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/instructor-do-using-methods)

*LO.3: Explain method parameters and use them in a C\# program*

*LO.4: Explain method return types and demonstrate them in a C\#
program*

The purpose of this demo is to show the learners how to call/use methods
after they have been defined and implemented. Go through the following
examples:

-   Add two ints

-   Multiply two ints

-   sayHi

-   errorMessage

Code the methods up and then show the learners how to call the methods.
Make sure you point out the difference between methods that return a
value and those that don't.

**Make sure you step through this code with the debugger so learners can
see how that is done! Demonstrate the Step Into debugging command.**


```
using System;

namespace MethodExample

{

class Program

{

static int sumInts(int num1, int num2)

{

return num1 + num2;

}

static int multInts(int num1, int num2)

{

return num1 \* num2;

}

static void sayHi()

{

Console.WriteLine(\"Hi!!!\");

}

static void errorMessage(String msg)

{

Console.WriteLine(\"An error has occurred. \" + msg);

}

public static void Main(string\[\] args)

{

int sum = sumInts(3, 4);

Console.WriteLine(sum);

int product = multInts(2, 19);

Console.WriteLine(product);

sayHi();

errorMessage(\"I have nothing more to say.\");

}

}

}
```
**Instructor Do: Refactor Rectangular Paving Company (20 min)**
---------------------------------------------------------------

The purpose of this demo is to get learners to think about how methods
can be used in their code and to introduce them to the concept of
refactoring (i.e., improving code without changing functionality).

Here, we'll go through an early version of Rectangular Paving Company
and factor out some repeated code into a method:

using System;

namespace RectPavingCompany

{

class RectPavingCompany

{

public static int promptDimension(String msg)

{

Console.WriteLine(\"What is the {0} of the driveway in feet?\", msg);

int x = Convert.ToInt32(Console.ReadLine());

return x;

}

public static void outputDimensions(String name, int value)

{

Console.WriteLine(

String.Format(\"The {0} of the driveway is {1} square feet.\", name,
value)

);

}

public static void outputCosts(String name, float value)

{

Console.WriteLine(

String.Format(\"The cost of the {0} is {1}.\", name, value)

);

}

public static void Main(String\[\] args)

{

int length = promptDimension(\"length\");

int width = promptDimension(\"width\");

float cementCost = 12.5f;

float framingCost = 8.25f;

int area = length \* width;

int perimeter = 2 \* length + 2 \* width;

outputDimensions(\"area\", area);

outputDimensions(\"perimeter\", perimeter);

outputCosts(\"cement\", area \* cementCost);

outputCosts(\"framing/footers\", perimeter \* framingCost);

}

}

}

**Recap (10 min)**
------------------

Recap what we learned in this lesson:

-   Declaring methods

-   Method signatures

-   Input parameters

-   Return types

-   Calling methods

**Lesson Plan: Debugging**
==========================

Open the
[[slidedeck]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/1-dot-1-2-slide-deck-part-2-debugging?module_item_id=33533)
for this lesson.

### **Purpose**

-   Debugging is invaluable. Sometimes our code is doing something other
    > than what we think it is doing. The debugger allows us to see what
    > is actually going on in a program vs. what we think is going on.

-   The debugger is one of the most important tools in a developer\'s
    > toolbelt, but many beginners do not take advantage of it and
    > suffer for it. Make sure you learn to use the debugger starting
    > now and make sure you use it regularly!

We expect learners to fumble with the debugger early on. We also realize
that the simple programs they\'re currently writing might not need a
debugger. But we\'ve found that learners who don\'t start using the
debugger early tend to not use it as they move forward, which makes
developing more complicated programs more difficult than it needs to be.

### **Narrative**

\"Have you ever had trouble with your car that you just couldn\'t figure
out how to fix? Maybe the check-engine light came on or the engine just
started running a little rough. You check the oil, go through the
troubleshooting steps in the owner\'s manual to no avail. Finally, you
take it into the shop, they hook up a diagnostic machine, diagnose the
problem, fix it, and you\'re on your way. Wouldn\'t it be nice to have a
diagnostic machine like that for your code? Something to let you really
see what\'s going on inside your program so you can see what is working
right and what isn\'t? Well, you\'re in luck! The debugger is just such
a tool and we\'ll learn how to use it in this lesson.\"

Reinforce this point: **The IDE and all of its features are your tools
of the trade. These are the tools you use to make your money, do your
job, and advance in your career. Your time investment in learning the
tools of your trade will pay off many times over! One of the most
important of these tools is the debugger. Learn to use it well and it
will save you countless hours over your career.**

### **Learning Outcomes**

By the end of this lesson, the learners will be able to:

6.  Execute a program in debug mode.

7.  Compare and contrast debug and regular mode execution.

8.  Set a breakpoint.

9.  Step through program statements after hitting a breakpoint.

10. Continue program execution after hitting a breakpoint.

11. Observe program values while debugging.

**Debugging Setup (5 min)**
---------------------------

*LO.1: Execute a program in debug mode*

*LO.2: Compare and contrast debug and regular mode execution*

*LO.3: Set a breakpoint*

Explain to the learners the concept of debugging and breakpoints.

-   Debug mode allows us to set breakpoints on executable statements.

-   This allows us to stop execution and observe the program state at a
    > particular point in the program.

**We Do: Debugging (10 min)**
-----------------------------

// (!!!)There is a corresponding page in Student Materials [[We Do:
Debugging]{.ul}](https://bootcampspot.instructure.com/courses/255/pages/we-do-debugging)

[[U01-M01-L2-DebuggingPractice-Activity.zip]{.ul}](https://bootcampspot.instructure.com/courses/255/files/82682/download?wrap=1)

We will set up a breakpoint. Have the learners work along with you as
you demonstrate.

5.  Have everyone open up the supplied version of Rectangular Paving
    > Company.

6.  Demonstrate setting a breakpoint on the first executable statement
    > (click in the gutter margin).

7.  Demonstrate starting the program in debug mode.

8.  Point out what the IDE looks like when the breakpoint is hit.

**Observing State and Stepping Through the Program (10 min)**
-------------------------------------------------------------

*LO.4: Step through program statements after hitting a breakpoint*

*LO.5: Continue program execution after hitting a breakpoint*

*LO.6: Observe program values while debugging*

Show the learners how to step through the code as part of the debugging
process.

7.  Point out the variables window.

8.  Show the learners what you see at this first breakpoint.

9.  Point out that we can only see the results of code that has
    > executed.

10. Step through the code, pointing out how the debugger interacts with
    > a program that is asking for input from the user. Show them how to
    > switch between the variable window and the output window so they
    > see how to interact with the program even in debug mode.

11. Point out how more variables become visible in the variable window
    > as you execute more statements.

12. Show them how to click "Continue Execution" so the program runs to
    > completion.

**Recap (10 min)**
------------------

Recap what we learned in this lesson:

-   The debugger is a powerful tool that everyone should use.

-   Breakpoints allow us to stop program execution and look at the state
    > of the program.

-   We can step through a program line by line.

-   This allows us to see what the program is actually doing vs. what we
    > think it is doing.
